module TDict.Internal exposing (..)

import Bytes exposing (Bytes)
import Bytes.Encode as Bytes
import Dict exposing (Dict)
import Http exposing (..)
import Task exposing (Task)


type TDict k v
    = TRef String



{- Internal -}
-- Contains stubs/stuff that will be removed/hidden/autogenerated later


newRef_ =
    -- @STUB
    Task.succeed <| TRef "magic-autogenerated"


insert k v tdict =
    case tdict of
        TRef ref ->
            tdict |> req (Bytes.sequence [ Bytes.string ref, Bytes.unsignedInt8 1, magicEncode k, magicEncode v ])


remove k tdict =
    case tdict of
        TRef ref ->
            tdict |> req (Bytes.sequence [ Bytes.string ref, Bytes.unsignedInt8 2, magicEncode k ])


get k tdict =
    case tdict of
        TRef ref ->
            tdict |> get_ (Bytes.sequence [ Bytes.string ref, magicEncode k ])


req : Bytes.Encoder -> TDict comparable v -> Task () (TDict comparable v)
req encoder tdict =
    -- @TODO inject scoped auth per app
    Http.task
        { method = "POST"
        , headers = []
        , url = "http://some-magic-place/_tdict/"
        , body = Http.bytesBody "application/octet-stream" (Bytes.encode encoder)
        , resolver = magicResolver
        , timeout = Nothing
        }
        |> alwaysReturn tdict


get_ : Bytes.Encoder -> TDict comparable v -> Task () (Maybe v)
get_ encoder tdict =
    -- @TODO inject scoped auth per app
    Http.task
        { method = "POST"
        , headers = []
        , url = "http://some-magic-place/_tdict/"
        , body = Http.bytesBody "application/octet-stream" (Bytes.encode encoder)
        , resolver = magicResolver
        , timeout = Nothing
        }
        -- @STUB
        |> alwaysReturn Nothing


alwaysReturn : v -> Task Http.Error x -> Task () v
alwaysReturn tdict task =
    task
        |> Task.mapError
            (\err ->
                let
                    _ =
                        Debug.log "tdict http error" (httpErrorToString err)
                in
                ()
            )
        |> Task.map (always tdict)


magicEncode v =
    Bytes.unsignedInt8 0


magicDecode bytes =
    Debug.todo "auto-inject right wire decoder"


magicResolver =
    Http.bytesResolver
        (\response ->
            case response of
                BadUrl_ urlString ->
                    Err <| BadUrl urlString

                Timeout_ ->
                    Err <| Timeout

                NetworkError_ ->
                    Err <| NetworkError

                BadStatus_ metadata body ->
                    -- @TODO use metadata better here
                    Err <| BadStatus metadata.statusCode

                GoodStatus_ metadata bytes ->
                    case magicDecode bytes of
                        Just x ->
                            Ok x

                        Nothing ->
                            Err <| BadBody <| "Failed to decode tdict response"
        )


httpErrorToString : Http.Error -> String
httpErrorToString err =
    case err of
        BadUrl url ->
            "HTTP Malformed url: " ++ url

        Timeout ->
            "HTTP Timeout exceeded"

        NetworkError ->
            "HTTP Network error"

        BadStatus code ->
            "Unexpected HTTP response code: " ++ String.fromInt code

        BadBody text ->
            "Unexpected HTTP response: " ++ text
